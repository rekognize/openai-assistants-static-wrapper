<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>AI Assistants</title>

    <link href="https://fastly.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
    <link href="https://fastly.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css" rel="stylesheet">

    <style>
        body {
            height: 100vh;
            margin: 0;
        }
        #assistants-list {
            overflow-y: auto;
        }
        #conversation {
            height: calc(100vh - 168px); /* Adjust based on navbar height */
            overflow-y: auto;
        }
        #question-form {
            display: flex;
            align-items: flex-end;
        }
        #question {
            flex-grow: 1;
            margin-right: 10px;
            resize: none;
            overflow: auto;
            max-height: 33vh; /* Set max-height to one-third of the viewport height */
        }
        #submit-btn {
            flex-shrink: 0;
            width: 80px;
            height: 62px;
        }
        #loading-conversation {
            text-align: center;
            margin: 40px;
        }
        #no-messages {
            text-align: center;
            margin: 40px;
        }
        .assistant-item {
            position: relative;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .assistant-info-icon {
            margin-left: 10px;
            cursor: pointer;
        }
        .user-message {
            width: fit-content;
            max-width: 80%;
            min-width: 20%;
            margin-left: auto;
        }
        .assistant-message {
            width: 100%;
        }
        .list-group-item.active {
            background-color: #052c65;
            border-color: #052c65;
        }
        #dropZone {
            border: 2px dotted #cfe2ff;
            border-radius: 8px;
            background: #f8f9fa;
            padding: 20px;
            text-align: center;
            color: #007bff;
            cursor: pointer;
        }
        #dropZone.hover {
            background-color: #cfe2ff;
        }
        .hidden {
            display: none;
        }
        .toast-container {
            position: fixed;
            top: 70px;
            right: 20px;
            z-index: 1055;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.min.js'></script>

</head>
<body>


<nav class="navbar bg-body-tertiary">
    <div class="container">
        <a class="navbar-brand" href="#">
            <span class="text-muted">Assistants</span>
        </a>

        <div class="d-flex">

            <div class="btn-group" role="group" aria-label="Basic example">
                <button class="btn btn-outline-secondary" onclick="downloadMessagesDocx()"
                       tabindex="0" data-bs-toggle="popover" data-bs-trigger="hover" data-bs-placement="auto"
                       data-bs-content="Click to download thread messages as a word file.">
                    <i class="bi bi-filetype-docx"></i>
                </button>
                <button class="btn btn-outline-secondary" onclick="downloadMessagesMd()"
                       tabindex="0" data-bs-toggle="popover" data-bs-trigger="hover" data-bs-placement="auto"
                       data-bs-content="Click to download thread messages as a markdown file.">
                    <i class="bi bi-filetype-md"></i>
                </button>
            </div>


            <button class="btn btn-outline-danger ms-2" onclick="resetThread()"
                   tabindex="0" data-bs-toggle="popover" data-bs-trigger="hover" data-bs-placement="auto"
                   data-bs-content="Click to reset this thread.">
                <i class="bi bi-x-lg"></i>
            </button>

        </div>

    </div>
</nav>


<div id="content" class="container mt-3">

    <div class="row">

        <div class="col-4">

            <div id="assistants-list" class="list-group">
                <div id="assistants-container" class="list-group">
                    <div id="loading-assistants" class="text-center">
                        <span class="spinner-border spinner-border-sm" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </span> Loading assistants...
                    </div>
                </div>
            </div>

            <ul id="file-list" class="list-group mt-3">
                <li id="data-files-header" class="list-group-item list-group-item-light text-dark">Data files</li>
                <li id="loading-files" class="list-group-item text-center" style="display: none;">
                    <span class="spinner-border spinner-border-sm" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </span> Loading files...
                </li>
            </ul>

            <div id="dropZone" class="mt-3">Drop your data files here.</div>
            <input id="dataFiles" type="file" multiple class="hidden" />

        </div>


        <div class="col-8">

            <div id="conversation">

                <div id="loading-conversation">
                    <span class="spinner-border spinner-border-sm" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </span> Loading conversation...
                </div>

            </div>

        </div>

    </div>

</div>


<nav class="navbar fixed-bottom bg-body-white">
    <div class="container">
        <div id="question-form" class="offset-4 w-100 my-2 ps-2">
            <textarea id="question" class="form-control" rows="2" placeholder="Type your question here..."></textarea>
            <button id="submit-btn" class="btn btn-secondary" onclick="submitQuestion()">Submit</button>
        </div>
    </div>
</nav>

<!-- Toast Messages Container -->
<div aria-live="polite" aria-atomic="true" class="position-relative">
    <div id="toast-container" class="toast-container">
    </div>
</div>

<div id="toast-template" class="toast align-items-center text-bg-primary border-0" role="alert" aria-live="assertive" aria-atomic="true">
    <div class="d-flex">
        <div class="toast-body">
            <!-- Toast message will go here -->
        </div>
        <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
    </div>
</div>

<!-- Reset Thread Confirmation Modal -->
<div class="modal fade" id="resetThreadModal" tabindex="-1" aria-labelledby="resetThreadModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="resetThreadModalLabel">Confirm Reset Thread</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                Are you sure you want to reset this thread? This action cannot be undone.
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" id="confirmResetButton">Reset Thread</button>
            </div>
        </div>
    </div>
</div>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js" integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js" integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy" crossorigin="anonymous"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            var popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'));
            var popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
                return new bootstrap.Popover(popoverTriggerEl, {
                    trigger: 'hover'
                });
            });

            var questionTextarea = document.getElementById('question');

            questionTextarea.addEventListener('input', function () {
                this.style.height = 'auto'; // Reset the height
                this.style.height = this.scrollHeight + 2 + 'px'; // Set the height to match content
            });

            questionTextarea.addEventListener('keydown', function (e) {
                if (e.key === 'Enter') {
                    if (e.shiftKey) {
                        // Allow new line if Shift key is pressed
                        return;
                    } else {
                        e.preventDefault();
                        // Submit the question
                        submitQuestion();
                    }
                }
            });
        });

        let selectedAssistantId = null;
        let selectedAssistantName = null;
        let assistantDictionary = {};
        let threadId = sessionStorage.getItem('threadId');
        const noMessagesDiv = `
                    <div id="no-messages">
                        <p>No messages in this thread yet.</p>
                        <p>Start the conversation by asking a question.</p>
                    </div>
                `;

        // Function to get the project key from the URL hash parameter
        function getProjectKeyFromURL() {
            const hash = window.location.hash;
            if (hash.startsWith('#')) {
                return hash.substring(1);
            }
            return null;
        }

        // Function to fetch the list of assistants
        async function fetchAssistants() {
            const projectKey = getProjectKeyFromURL();
            if (!projectKey) {
                document.getElementById('assistants-container').innerText = 'Project key not found in URL.';
                document.getElementById('conversation').innerText = '';
                return;
            }

            const url = 'https://api.openai.com/v1/assistants';
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                const data = await response.json();

                if (!data.data) {
                    throw new Error('Assistants data is not defined');
                }

                await displayAssistants(projectKey, data.data);

                return data.data;  // Return the assistants data

            } catch (error) {
                console.error('Error fetching assistants:', error);
                document.getElementById('assistants-list').innerText = `Failed to fetch assistants: ${error.message}`;
                showToast('Failed to fetch assistants.', 'danger');
            }
        }

        // Function to display the list of assistants
        async function displayAssistants(projectKey, assistants) {
            const containerElement = document.getElementById('assistants-container');
            containerElement.innerHTML = '';

            if (assistants.length === 0) {
                containerElement.innerText = 'No assistants found.';
                return;
            }

            assistants.reverse().forEach((assistant, index) => {
                assistantDictionary[assistant.id] = assistant.name;

                const description = assistant.description ? `<span class="small">${assistant.description}</span>` : '';
                const instructions = assistant.instructions ? `<p><strong>Instructions:</strong> ${assistant.instructions}</p>` : '';
                const model = assistant.model ? `<p><strong>Model:</strong> ${assistant.model}</p>` : '';
                const tools = assistant.tools && assistant.tools.length > 0 ?
                    `<p><strong>Tools:</strong> ${assistant.tools.map(tool => tool.type).join(', ')}</p>` : '';

                const assistantElement = document.createElement('a');
                assistantElement.className = 'list-group-item list-group-item-action assistant-item';
                assistantElement.dataset.id = assistant.id;
                assistantElement.innerHTML = `
                    <div>
                        <strong class="d-block">${assistant.name}</strong>
                        ${description}
                    </div>
                    <i class="bi bi-info-circle assistant-info-icon" tabindex="0" data-bs-toggle="popover" data-bs-content="${instructions}${model}${tools}" data-html="true"></i>
                `;
                assistantElement.onclick = () => {
                    // Check if the clicked assistant is the same as the already selected one
                    if (selectedAssistantId === assistant.id) {
                        return; // Do nothing if the same assistant is clicked
                    }
                    selectAssistant(projectKey, assistants, assistant.id, assistant.name, assistantElement);
                };
                containerElement.appendChild(assistantElement);

                // Initialize Bootstrap Popover with html: true
                const popover = new bootstrap.Popover(assistantElement.querySelector('.assistant-info-icon'), {
                    html: true,
                    trigger: 'hover'
                });

                // Set initial popover content
                const isSelected = index === 0 ? '<p class="text-success"><i>Selected as your assistant.</i></p>' : '<p class="text-secondary"><i>Not selected. Click to select as your assistant.</i></p>';
                popover.setContent({ '.popover-body': `${isSelected}${instructions}${model}${tools}` });

                // Select the first assistant by default
                if (index === 0) {
                    selectAssistant(projectKey, assistants, assistant.id, assistant.name, assistantElement);
                }
            });
        }

        // Function to select an assistant
        async function selectAssistant(projectKey, assistants, assistantId, assistantName, element) {
            selectedAssistantId = assistantId;
            selectedAssistantName = assistantName;

            // Set the selected assistant element as active
            const assistantElements = document.querySelectorAll('.list-group-item');
            assistantElements.forEach(el => el.classList.remove('active'));
            element.classList.add('active');

            // Update Bootstrap Popovers to reflect the selected status
            await updateAssistantTooltips(projectKey, assistants);

            console.log(`Selected Assistant ID: ${assistantId}`);
            showToast('Assistant selected successfully.', 'success', `${selectedAssistantName}`);
        }

        // Function to update assistant tooltips with file information
        async function updateAssistantTooltips(projectKey, assistants) {
            const assistantElements = document.querySelectorAll('.list-group-item');
            const promises = Array.from(assistantElements).map(async (el) => {
                const assistantInfoIcon = el.querySelector('.assistant-info-icon');
                if (assistantInfoIcon) {
                    const popover = bootstrap.Popover.getInstance(assistantInfoIcon);
                    if (popover) {
                        const assistant = assistants.find(a => a.id === el.dataset.id);
                        let files = '';

                        if (assistant && assistant.tool_resources.file_search.vector_store_ids.length > 0) {
                            const vectorStoreId = assistant.tool_resources.file_search.vector_store_ids[0];
                            const fileNames = await fetchAssistantFiles(projectKey, vectorStoreId);
                            files = fileNames.length > 0
                                ? `<p><strong>Files:</strong></p><ul>${fileNames.map(fileName => `<li>${fileName}</li>`).join('')}</ul>`
                                : '';
                        }

                        const instructions = assistant.instructions ? `<p><strong>Instructions:</strong> ${assistant.instructions}</p>` : '';
                        const model = assistant.model ? `<p><strong>Model:</strong> ${assistant.model}</p>` : '';
                        const tools = assistant.tools && assistant.tools.length > 0 ?
                            `<p><strong>Tools:</strong> ${assistant.tools.map(tool => tool.type).join(', ')}</p>` : '';
                        const isSelected = el.dataset.id === selectedAssistantId ? '<p class="text-success"><i>Selected as your assistant.</i></p>' : '<p class="text-secondary"><i>Not selected. Click to select as your assistant.</i></p>';
                        popover.setContent({ '.popover-body': `${isSelected}${instructions}${model}${tools}${files}` });
                    }
                }
            });

            await Promise.all(promises);
        }

        // Function to fetch assistant files from the vector store
        async function fetchAssistantFiles(projectKey, vectorStoreId) {
            const url = `https://api.openai.com/v1/vector_stores/${vectorStoreId}/files`;
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                const fileList = await response.json();

                if (response.ok) {
                    const fileIds = fileList.data.map(file => file.id);
                    const fileNames = await fetchFileNames(projectKey, fileIds);
                    return fileNames;
                } else {
                    console.error('Error fetching assistant files:', fileList);
                    return [];
                }
            } catch (error) {
                console.error('Error fetching assistant files:', error);
                return [];
            }
        }

        // Function to fetch filenames
        async function fetchFileNames(projectKey, fileIds) {
            const promises = fileIds.map(async fileId => {
                const url = `https://api.openai.com/v1/files/${fileId}`;
                const options = {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${projectKey}`,
                        'Content-Type': 'application/json',
                        'OpenAI-Beta': 'assistants=v2'
                    }
                };

                try {
                    const response = await fetch(url, options);
                    const fileData = await response.json();

                    if (response.ok) {
                        return fileData.filename;
                    } else {
                        console.error('Error fetching file:', fileData);
                        return null;
                    }
                } catch (error) {
                    console.error('Error fetching file:', error);
                    return null;
                }
            });

            try {
                const fileNames = await Promise.all(promises);
                return fileNames.filter(name => name !== null);
            } catch (error) {
                console.error('Error fetching file names:', error);
                return [];
            }
        }

        // Function to scroll to the bottom of the conversation
        function scrollToBottom() {
            const conversationElement = document.getElementById('conversation');
            conversationElement.scrollTop = conversationElement.scrollHeight;
        }

        // Function to submit a question
        async function submitQuestion() {
            const projectKey = getProjectKeyFromURL();
            const questionTextarea = document.getElementById('question');
            const questionText = questionTextarea.value.trim();

            // Reset textarea height
            questionTextarea.style.height = 'auto';

            // Check assistant and if the textarea is not empty before submitting
            if (!selectedAssistantId) {
                showToast('Please select an assistant.', 'primary');
                return;
            } else if (!questionText) {
                showToast('Please enter a question.', 'primary');
                return;
            }

            // Remove the no-messages div if it exists
            const noMessagesDiv = document.getElementById('no-messages');
            if (noMessagesDiv) {
                noMessagesDiv.remove();
            }

            // Disable submit button and add spinner
            const submitButton = document.getElementById('submit-btn');
            submitButton.disabled = true;
            submitButton.innerHTML = 'Submit <div class="spinner-border spinner-border-sm" role="status"><span class="visually-hidden">Loading...</span></div>';

            displayMessage('user', questionText);

            await addQuestionToThread(projectKey, questionText);

            // Reset textarea question
            questionTextarea.value = '';

            // Create an empty assistant response element
            const assistantResponseElement = renderAssistantMessageElement(selectedAssistantName, '');
            document.getElementById('conversation').appendChild(assistantResponseElement);

            // Select the response text element within the assistant message element
            const responseTextElement = assistantResponseElement.querySelector('.message-body');
            await createRun(projectKey, responseTextElement);

            // Enable submit button and remove spinner
            submitButton.disabled = false;
            submitButton.innerHTML = 'Submit';
        }

        function renderUserMessageElement(text) {
            const messageElement = document.createElement('div');
            messageElement.className = 'message user-message alert alert-secondary border-0 mb-3';
            messageElement.innerHTML = `<div style="white-space: pre-wrap;">${text}</div>`;
            return messageElement;
        }

        function renderAssistantMessageElement(assistantName, text) {
            const messageElement = document.createElement('div');
            messageElement.className = 'message assistant-message alert alert-light mb-3';
            messageElement.innerHTML = `
                <h6 class="alert-heading"><strong>${assistantName}</strong></h6>
                <div class="message-body">${marked.parse(text)}</div>
            `;
            return messageElement;
        }

        // Function to prepend a message when displaying the initial thread
        function prependMessage(sender, text) {
            const conversationElement = document.getElementById('conversation');
            let messageElement;
            if (sender === 'user') {
                messageElement = renderUserMessageElement(text);
            } else {
                messageElement = renderAssistantMessageElement(sender, text);
            }
            conversationElement.insertBefore(messageElement, conversationElement.firstChild);
            scrollToBottom();
        }

        // Function to display a message in the conversation
        function displayMessage(sender, text) {
            const conversationElement = document.getElementById('conversation');
            let messageElement;
            if (sender === 'user') {
                messageElement = renderUserMessageElement(text);
            } else {
                messageElement = renderAssistantMessageElement(sender, text);
            }
            conversationElement.appendChild(messageElement);
            scrollToBottom();
        }

        // Function to create a new thread
        async function createThread(projectKey) {
            const url = 'https://api.openai.com/v1/threads';
            const options = {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                const data = await response.json();
                console.log('Thread created:', data);
                showToast('New thread created successfully.', 'success');
                return data.id;
            } catch (error) {
                console.error('Error creating thread:', error);
                showToast('Failed to create thread.', 'danger');
            }
        }

        async function fetchThreadFiles(projectKey, fileIds) {
            const promises = fileIds.map(fileId => {
                const url = `https://api.openai.com/v1/files/${fileId}`;
                const options = {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${projectKey}`,
                        'Content-Type': 'application/json',
                        'OpenAI-Beta': 'assistants=v2'
                    }
                };
                return fetch(url, options).then(response => response.json()).catch(error => {
                    console.error('Error fetching file:', fileId, error);
                    return null;
                });
            });

            try {
                const files = await Promise.all(promises);
                const validFiles = files.filter(file => file !== null);

                console.log('Fetched files:', validFiles);

                if (validFiles.length > 0) {
                    validFiles.forEach(file => displayFile(file));
                }
            } catch (error) {
                console.error('Error fetching files:', error);
            }
        }

        async function listThreadFiles(projectKey, threadId) {
            const fileList = document.getElementById('file-list');
            let loadingFilesElement = document.getElementById('loading-files');
            // Create mock loading-files element for reset thread
            if (!loadingFilesElement) {
                loadingFilesElement = document.createElement('li');
                loadingFilesElement.id = 'loading-files';
                fileList.appendChild(loadingFilesElement);
            }

            loadingFilesElement.style.display = 'block'; // Show loading-files

            const url = `https://api.openai.com/v1/threads/${threadId}`;
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                if (response.ok) {
                    const data = await response.json();
                    const fileIds = data.tool_resources.code_interpreter.file_ids;
                    if (fileIds.length > 0) {
                        await fetchThreadFiles(projectKey, fileIds);
                    } else {
                        loadingFilesElement.style.display = 'none';
                        fileList.innerHTML += '<li id="no-files" class="list-group-item text-muted">No files available.</li>';
                    }
                } else {
                    console.error('Error fetching thread files:', threadId);
                    loadingFilesElement.style.display = 'none';
                    fileList.innerHTML += '<li class="list-group-item text-muted">Failed to load files.</li>';
                    showToast('Failed to fetch thread files.', 'danger');
                }
            } catch (error) {
                console.error('Error fetching thread files:', error);
                loadingFilesElement.style.display = 'none';
                fileList.innerHTML += '<li class="list-group-item text-muted">Failed to load files.</li>';
                showToast('Failed to fetch thread files.', 'danger');
            } finally {
                loadingFilesElement.style.display = 'none'; // Hide loading-files after fetching files
            }
        }

        // Function to validate an existing thread
        async function validateThread(projectKey, threadId) {
            const url = `https://api.openai.com/v1/threads/${threadId}`;
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                if (response.ok) {
                    console.log('Thread is valid:', threadId);
                    return true;
                } else {
                    console.log('Thread is not valid:', threadId);
                    return false;
                }
            } catch (error) {
                console.error('Error validating thread:', error);
                return false;
            }
        }

        // Function to add a question to the thread
        async function addQuestionToThread(projectKey, questionText) {
            const url = `https://api.openai.com/v1/threads/${threadId}/messages`;
            const options = {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                },
                body: JSON.stringify({ role: 'user', content: questionText })
            };

            try {
                const response = await fetch(url, options);
                const data = await response.json();
                console.log('Question added to thread:', data);
                return data;
            } catch (error) {
                console.error('Error adding question to thread:', error);
                showToast('Failed to add question to thread.', 'danger');

                const submitButton = document.getElementById('submit-btn');
                submitButton.disabled = false;
                submitButton.innerHTML = 'Submit';
            }
        }

        // Function to create a run and get the response
        async function createRun(projectKey, responseTextElement) {
            const runUrl = `https://api.openai.com/v1/threads/${threadId}/runs`;
            const runOptions = {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                },
                body: JSON.stringify({
                    assistant_id: selectedAssistantId,
                    stream: true
                })
            };

            try {
                const runResponse = await fetch(runUrl, runOptions);
                const decoder = new TextDecoder('utf-8');
                let currentMessageContent = ''; // Buffer for current message content
                let isFirstMessage = true; // Flag to check if it's the first message

                for await (const chunk of runResponse.body) {
                    const content = decoder.decode(chunk, { stream: true });
                    const lines = content.toString().split('\n').filter(line => line.trim() !== '');
                    let event;
                    let data;

                    for (const line of lines) {
                        if (line.startsWith('event: ')) {
                            event = line.replace('event: ', '');
                            console.log(event);
                        }
                        if (line.startsWith('data: ')) {
                            const dataLine = line.replace('data: ', '');
                            try {
                                data = JSON.parse(dataLine);
                                console.log(data);
                            } catch (error) {
                                console.log('Cannot parse:', dataLine);
                                continue; // Skip this line and continue with the next one
                            }

                            if (event === 'thread.message.delta') {
                                const deltaContent = data.delta.content[0];
                                if (deltaContent.type === 'text') {
                                    const delta = deltaContent.text.value;
                                    currentMessageContent += delta;
                                    responseTextElement.innerHTML = marked.parse(currentMessageContent);
                                }
                            } else if (event === 'thread.message.created') {
                                // Check if it's the first message to avoid duplicating the response element
                                if (!isFirstMessage) {
                                    // Initialize new message buffer
                                    currentMessageContent = '';
                                    const assistantResponseTextElement = renderAssistantMessageElement(selectedAssistantName, '');
                                    document.getElementById('conversation').appendChild(assistantResponseTextElement);

                                    responseTextElement = assistantResponseTextElement.querySelector('.message-body');
                                } else {
                                    isFirstMessage = false;
                                }
                            } else if (event === 'thread.message.completed') {
                                // Finalize the message with annotations
                                currentMessageContent = await processAnnotations(currentMessageContent, data.content[0].text.annotations, projectKey);
                                responseTextElement.innerHTML = marked.parse(currentMessageContent);
                                currentMessageContent = ''; // Reset the buffer for the next message
                            }
                        }
                    }
                    scrollToBottom();
                }
            } catch (error) {
                console.error('Error creating run:', error);
                showToast('Failed to get response from assistant.', 'danger');
                displayMessage(selectedAssistantName, 'An error occurred while fetching the response.');

                const submitButton = document.getElementById('submit-btn');
                submitButton.disabled = false;
                submitButton.innerHTML = 'Submit';
            }
        }

        // Function to fetch and display messages from an existing thread
        async function fetchThreadMessages(projectKey, threadId) {
            const conversationElement = document.getElementById('conversation');
            conversationElement.innerHTML = `
                <div id="loading-conversation">
                    <span class="spinner-border spinner-border-sm" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </span> Fetching messages...
                </div>
            `;

            const url = `https://api.openai.com/v1/threads/${threadId}/messages`;
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                const data = await response.json();
                console.log('Thread messages:', data);

                conversationElement.innerHTML = '';

                if (data.data && data.data.length > 0) {
                    const messages = data.data;
                    for (const message of messages) {
                        const sender = message.role === 'user' ? 'user' : assistantDictionary[message.assistant_id];
                        let content = message.content[0].text.value;

                        content = await processAnnotations(content, message.content[0].text.annotations, projectKey);

                        prependMessage(sender, content);
                    }
                } else {
                    // Handle the case when there are no messages
                    console.log('No messages in this thread yet.');
                    conversationElement.innerHTML = noMessagesDiv;
                }
            } catch (error) {
                console.error('Error fetching thread messages:', error);
                conversationElement.innerHTML = '<p>Failed to load conversation. Please try again later.</p>';

                showToast('Error fetching thread messages.', 'danger');
            }
        }

        // Function to process annotations in the content
        async function processAnnotations(content, annotations, projectKey) {
            for (let index = 0; index < annotations.length; index++) {
                const annotation = annotations[index];
                if (annotation.file_citation) {
                    const fileCitation = annotation.file_citation;
                    try {
                        const citedFile = await fetchFileData(projectKey, fileCitation.file_id);
                        const fileInfo = `(${citedFile.filename})`;
                        content = content.replace(annotation.text, ` [${index + 1}] ${fileInfo}`);
                    } catch (error) {
                        console.error(`File with id ${fileCitation.file_id} not found:`, error);
                        content = content.replace(annotation.text, ' (Reference file is not available)');
                    }
                } else if (annotation.file_path) {
                    const filePath = annotation.file_path;
                    const downloadLink = `download-url/${filePath.file_id}`; // TODO #1 Add download function and link
                    content = content.replace(annotation.text, downloadLink);
                }
            }
            return content;
        }

        // Function to fetch file object
        async function fetchFileData(projectKey, fileId) {
            const url = `https://api.openai.com/v1/files/${fileId}`;
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                if (response.ok) {
                    return await response.json();
                } else {
                    console.error('Error fetching file:', fileId);
                    return null;
                }
            } catch (error) {
                console.error('Error fetching file:', fileId, error);
                return null;
            }
        }

        // Function to initialize the session and create a thread if needed
        async function initializeSession() {
            const projectKey = getProjectKeyFromURL();
            const assistants = await fetchAssistants();  // Wait for assistants to be fetched

            if (assistants) {
                // Populate the assistant dictionary
                assistants.forEach(assistant => {
                    assistantDictionary[assistant.id] = assistant.name;
                });

                if (!threadId) {
                    // Clear the conversation area and show a message
                    document.getElementById('conversation').innerHTML = noMessagesDiv;

                    threadId = await createThread(projectKey);
                    sessionStorage.setItem('threadId', threadId);
                } else {
                    const isValidThread = await validateThread(projectKey, threadId);
                    if (!isValidThread) {
                        // Clear the conversation area and show a message
                        document.getElementById('conversation').innerHTML = noMessagesDiv;

                        threadId = await createThread(projectKey);
                        sessionStorage.setItem('threadId', threadId);
                    } else {
                        await fetchThreadMessages(projectKey, threadId);  // Fetch messages only after assistants are loaded
                        await listThreadFiles(projectKey, threadId);  // List thread files separately
                    }
                }
                // Fetch assistant files after initialization
                await updateAssistantTooltips(projectKey, assistants);
            }
        }

        // Initialize the session and fetch assistants when the page loads
        window.addEventListener('load', async () => {
            await initializeSession();
            scrollToBottom();
        });

        // Function to reset the thread
        async function resetThread() {
            const projectKey = getProjectKeyFromURL();

            // Show the confirmation modal
            const resetThreadModal = new bootstrap.Modal(document.getElementById('resetThreadModal'));
            resetThreadModal.show();

            // Handle the confirmation button click
            document.getElementById('confirmResetButton').onclick = async () => {
                // Clear the conversation area and show a message
                document.getElementById('conversation').innerHTML = noMessagesDiv;

                // Hide the modal
                resetThreadModal.hide();

                // Create a new thread
                threadId = await createThread(projectKey);
                sessionStorage.setItem('threadId', threadId);

                // Reset thread files
                const fileList = document.getElementById('file-list');
                fileList.innerHTML = `
                    <li id="data-files-header" class="list-group-item list-group-item-light text-dark">Data files</li>
                `;

                // Clear any stored messages and reinitialize the session
                await initializeSession();
            };
        }

        // Function to download all messages as a markdown file
        function downloadMessagesMd() {
            const conversationElement = document.getElementById('conversation');
            const messages = conversationElement.querySelectorAll('.message');

            if (messages.length === 0) {
                showToast('No messages in the thread.', 'primary');
                return;
            }

            let markdownContent = '';

            messages.forEach(message => {
                let sender, content;
                if (message.classList.contains('user-message')) {
                    sender = 'User';
                    content = message.innerText;
                } else if (message.classList.contains('assistant-message')) {
                    sender = message.querySelector('.alert-heading').innerText;
                    content = message.querySelector('.message-body').innerText;
                } else {
                    // If message does not match expected classes, skip it
                    return;
                }

                markdownContent += `**${sender}**\n\n${content}\n\n`;
            });

            const blob = new Blob([markdownContent], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'conversation.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            showToast('Markdown file downloaded successfully.', 'success');
        }

        // Function to download all messages as a DOCX file
        async function downloadMessagesDocx() {
            const { Document, Packer, Paragraph, TextRun } = window.docx;

            const conversationElement = document.getElementById('conversation');
            const messages = conversationElement.querySelectorAll('.message');

            if (messages.length === 0) {
                showToast('No messages in the thread.', 'primary');
                return;
            }

            const docChildren = [];

            messages.forEach(message => {
                let sender, content;
                if (message.classList.contains('user-message')) {
                    sender = 'User';
                    content = message.innerText;
                } else if (message.classList.contains('assistant-message')) {
                    sender = message.querySelector('.alert-heading').innerText;
                    content = message.querySelector('.message-body').innerText;
                } else {
                    // If message does not match expected classes, skip it
                    return;
                }

                const senderRun = new TextRun({
                    text: sender,
                    bold: true,
                });

                const contentRuns = content.split('\n').map(line => new TextRun({ text: line, break: 1 }));

                docChildren.push(
                    new Paragraph({
                        children: [senderRun],
                    }),
                    new Paragraph({
                        children: contentRuns,
                    }),
                    new Paragraph({ // Empty paragraph to add a blank line
                        children: [new TextRun("\n")],
                    })
                );
            });

            const doc = new Document({
                sections: [
                    {
                        properties: {},
                        children: docChildren,
                    },
                ],
            });

            Packer.toBlob(doc).then(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'conversation.docx';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }).catch(err => {
                console.error('Error creating DOCX file:', err);
                showToast('Error creating DOCX file.', 'danger');
            });
            showToast('Word file downloaded successfully.', 'success');
        }

        // Function to show toast messages
        function showToast(message, type='primary', details='') {
            const toastContainer = document.getElementById('toast-container');
            const toastTemplate = document.getElementById('toast-template');

            // Clone the toast template
            const newToast = toastTemplate.cloneNode(true);
            newToast.id = ''; // Clear the ID to avoid duplicate IDs

            // Set the toast type
            newToast.classList.remove('text-bg-primary', 'text-bg-success', 'text-bg-danger', 'text-bg-warning', 'text-bg-info');
            newToast.classList.add(`text-bg-${type}`);

            // Set the toast message
            const toastBody = newToast.querySelector('.toast-body');
            toastBody.innerHTML = `<strong>${message}</strong>`;
            if (details) {
                toastBody.innerHTML += `<br><small>${details}</small>`;
            }

            // Append the new toast to the container
            toastContainer.appendChild(newToast);

            // Initialize the new toast
            const bootstrapToast = new bootstrap.Toast(newToast);
            bootstrapToast.show();

            // Remove the toast from the DOM after it hides
            newToast.addEventListener('hidden.bs.toast', () => {
                newToast.remove();
            });
        }

        // File uploads

        function displayFile(file) {
            let noFilesElement = document.getElementById('no-files');
            // Remove no-files
            if (noFilesElement) {
                noFilesElement.remove();
            }

            const fileList = document.getElementById('file-list');
            const fileItem = document.createElement('li');
            fileItem.className = 'list-group-item';
            fileItem.innerHTML = `<small>${file.filename} (${file.bytes} bytes)</small>`;

            // Insert the new file item after the header
            const headerElement = document.getElementById('data-files-header');
            if (headerElement) {
                headerElement.insertAdjacentElement('afterend', fileItem);
            } else {
                fileList.appendChild(fileItem);
            }
        }

        document.getElementById('dropZone').addEventListener('click', function () {
            document.getElementById('dataFiles').click();
        });

        document.getElementById('dropZone').addEventListener('dragover', function (e) {
            e.preventDefault();
            this.classList.add('hover');
        });

        document.getElementById('dropZone').addEventListener('dragleave', function () {
            this.classList.remove('hover');
        });

        document.getElementById('dropZone').addEventListener('drop', function (e) {
            e.preventDefault();
            this.classList.remove('hover');
            uploadFiles(e.dataTransfer.files);
        });

        document.getElementById('dataFiles').addEventListener('change', function (e) {
            uploadFiles(e.target.files);
        });

        async function uploadFiles(files) {
            const projectKey = getProjectKeyFromURL();
            const url = 'https://api.openai.com/v1/files';
            const fileList = Array.from(files);

            for (const file of fileList) {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('purpose', 'assistants');

                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${projectKey}`,
                        },
                        body: formData,
                    });

                    if (response.ok) {
                        const data = await response.json();
                        console.log('File uploaded successfully:', data);

                        const fileId = data.id;
                        await addFilesToThread(projectKey, threadId, [fileId]);
                        displayFile(data);
                        showToast('File uploaded successfully.', 'success', `${file.name}`);
                    } else {
                        console.error('Error uploading file:', file);
                        showToast('Failed to upload file.', 'danger', `${file.name}`);
                    }
                } catch (error) {
                    console.error('Error uploading file:', error);
                    showToast('Failed to upload file.', 'danger', `${file.name}`);
                }
            }
        }

        async function getCurrentFileIds(projectKey, threadId) {
            const url = `https://api.openai.com/v1/threads/${threadId}`;
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                if (response.ok) {
                    const data = await response.json();
                    return data.tool_resources.code_interpreter.file_ids || [];
                } else {
                    console.error('Error fetching thread:', threadId);
                    return [];
                }
            } catch (error) {
                console.error('Error fetching thread:', threadId, error);
                return [];
            }
        }

        async function addFilesToThread(projectKey, threadId, fileIds) {
            // Get the current file IDs
            const currentFileIds = await getCurrentFileIds(projectKey, threadId);

            // Combine current and new file IDs
            const combinedFileIds = currentFileIds.concat(fileIds);

            const url = `https://api.openai.com/v1/threads/${threadId}`;
            const options = {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                },
                body: JSON.stringify({
                    tool_resources: {
                        code_interpreter: {
                            file_ids: combinedFileIds
                        }
                    }
                })
            };

            try {
                const response = await fetch(url, options);
                if (response.ok) {
                    const data = await response.json();
                    console.log('Thread updated with file:', data);
                } else {
                    console.error('Error updating thread with file.');
                }
            } catch (error) {
                console.error('Error updating thread with file:', error);
            }
        }

    </script>
</body>
</html>
